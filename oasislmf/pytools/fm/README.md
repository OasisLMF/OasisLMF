# Financial Module (fmpy)

The Financial Module (FM) calculates insured losses by applying financial terms such as deductibles, limits, and policy structures to ground-up losses. This Python implementation (`fmpy`) provides high-performance loss computation using NumPy and Numba.

## Quick Start

### Basic Usage

```python
from oasislmf.pytools.fm.manager import run

# Create financial structure files (one-time setup)
run(create_financial_structure_files=True,
    allocation_rule=2,
    static_path='./static')

# Run FM computation
run(create_financial_structure_files=False,
    allocation_rule=2,
    files_in=['/path/to/gul_stream'],
    files_out=['/path/to/fm_output'],
    static_path='./static',
    net_loss=None,
    storage_method='sparse',
    low_memory=False,
    sort_output=False)
```

### Command Line

```bash
# Using the oasislmf CLI
oasislmf model run --config oasislmf.json

# Or directly with fmpy
fmpy -a2 -p static < gul_stream > fm_output
```

## Features

- **High Performance**: Numba JIT compilation for near-native speed
- **Memory Efficient**: Sparse storage for large sample counts
- **Flexible Output**: Gross loss, net loss, or both
- **Multiple Allocation Rules**: Support for allocation rules 0, 1, and 2
- **Layer Support**: Multi-layer policies with cross-layer terms

## Input Files

The FM requires the following static files in the `static_path` directory:

| File | Description |
|------|-------------|
| `fm_programme.bin` | Hierarchy of nodes (levels and aggregation IDs) |
| `fm_policytc.bin` | Policy terms and conditions per node/layer |
| `fm_profile.bin` | Financial profile details (deductibles, limits) |
| `fm_xref.bin` | Mapping from internal nodes to output IDs |

These files are typically generated by the OasisLMF model preparation step.

## Configuration Options

### Allocation Rules

| Rule | Description | Use Case |
|------|-------------|----------|
| 0 | No back allocation | Output at aggregate level only |
| 1 | Proportional to ground-up | Distribute by original loss |
| 2 | Pro-rata | Distribute proportionally at each level |

```python
# Example: Use allocation rule 2 (most common)
run(allocation_rule=2, ...)
```

### Net Loss Output

| Option | Behavior |
|--------|----------|
| `None` | Output gross loss only |
| `''` | Output net loss only (to stdout/files_out) |
| `'-'` | Output gross to files_out, net to stdout |
| `'/path'` | Output gross to files_out, net to path |

```python
# Gross loss only
run(net_loss=None, files_out=['/path/gross.bin'], ...)

# Net loss only
run(net_loss='', files_out=['/path/net.bin'], ...)

# Both (gross to file, net to stdout)
run(net_loss='-', files_out=['/path/gross.bin'], ...)
```

### Memory Options

```python
# Low memory mode: uses disk-backed arrays
run(low_memory=True, ...)

# Standard mode: faster, uses more RAM
run(low_memory=False, ...)
```

### Output Ordering

```python
# Sorted output (by output_id)
run(sort_output=True, ...)

# Unsorted (faster, order follows computation)
run(sort_output=False, ...)
```

## Understanding the Output

### Stream Format

The output is a binary stream with the following structure:

```
Header: stream_type (4 bytes) + max_sidx (4 bytes)

Per output item:
  event_id (int32)
  output_id (int32)
  sidx=-5, max_loss (float32)     # Maximum loss
  sidx=-4, chance_of_loss (float32)  # Probability
  sidx=-3, tiv (float32)          # Total Insured Value
  sidx=-1, mean_loss (float32)    # Expected loss
  [sidx, loss]...                 # Sample losses
  sidx=0, 0.0                     # Delimiter
```

### Converting to CSV

```bash
# Using outputtocsv tool
fmpy ... | outputtocsv > results.csv
```

## Supported Financial Terms

The FM supports a wide range of calculation rules:

| Category | Terms |
|----------|-------|
| Deductibles | Flat, % of TIV, % of loss, minimum, maximum |
| Limits | Flat, % of TIV, % of loss |
| Attachments | Attachment point for excess policies |
| Shares | Participation %, co-insurance |
| Franchises | Franchise deductible (full payout above threshold) |

See `policy.py` for the complete list of supported `calcrule_id` values.

## Performance Tips

### 1. Use Allocation Rule

As back allocation is only done once, rule 1 is faster that rule 2 but less precise.
However, the performance of fmpy with rule 2 is generally good enough to not be an issue
and should, therefor, be preferred by default.

### 2. Disable Sorting Unless Needed

```python
run(sort_output=False, ...)  # Faster
```

### 3. Use Low Memory Mode for Large Models

```python
run(low_memory=True, ...)  # Trades speed for memory
```

### 4. Pre-warm Numba Cache

The first run compiles JIT functions. Subsequent runs are faster:

```bash
# Warm-up run with small data
fmpy -a2 -p static < small_gul > /dev/null

# Production run (uses cached compilation)
fmpy -a2 -p static < full_gul > output
```

## Troubleshooting

### Common Errors

**"Stream read error in fm"**
- Input stream format is incorrect
- Upstream process (gulcalc) failed

**"unsupported stream_type"**
- Input is not a valid GUL, FM, or LOSS stream
- Check upstream pipeline

**"duplicated sidx in input stream"**
- Same sample index appears twice for one item
- Input data corruption

### Debugging

If computation fails, check `event_error.json`:

```json
{
    "event_index": 42,
    "event_id": 12345,
    "agg_id": 7,
    "node_level_id": 3
}
```

This identifies the failing event and node.

### Validation

Compare fmpy output with reference:

```python
from oasislmf.pytools.fm.compare import compare_streams

with open('gul.bin', 'rb') as gul, \
     open('fm_test.bin', 'rb') as test, \
     open('fm_ref.bin', 'rb') as ref:
    result = compare_streams(gul, test, ref, precision=5)
    print(result)  # Empty string = match
```

## Architecture

```
Input Stream (GUL/FM)
        │
        ▼
┌───────────────────┐
│   Stream Reader   │  Parse binary, populate sparse arrays
└───────────────────┘
        │
        ▼
┌───────────────────┐
│ Level 1 (Items)   │  Read losses, queue parents
├───────────────────┤
│ Level 2           │  Aggregate → Apply Profile → Back Allocate
├───────────────────┤
│ Level N (Root)    │  Final computation
└───────────────────┘
        │
        ▼
┌───────────────────┐
│   Stream Writer   │  Write results to binary stream
└───────────────────┘
        │
        ▼
Output Stream (FM)
```

## File Reference

| File | Purpose |
|------|---------|
| `manager.py` | Entry point, orchestration |
| `financial_structure.py` | Parse static files, build node arrays |
| `compute_sparse.py` | Core computation engine |
| `back_allocation.py` | Distribute losses to children |
| `stream_sparse.py` | Binary stream I/O |
| `policy.py` | Financial term calculations |
| `policy_extras.py` | Calculations with extras tracking |
| `common.py` | Shared constants and types |

## Further Reading

- [Technical Documentation](TECHNICAL.md) - Detailed implementation documentation
- [FM Architecture](../fm_architecture.md) - High-level architecture overview
- [OasisLMF Documentation](https://oasislmf.github.io/) - Full platform documentation
